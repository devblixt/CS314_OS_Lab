
This program allows you to see how address translations are performed in a
system with segmentation. The segmentation that this system uses is pretty
simple: an address space has just *two* segments; further, the top bit of the
virtual address generated by the process determines which segment the address
is in: 0 for segment 0 (where, say, code and the heap would reside) and 1 for
segment 1 (where the stack lives). Segment 0 grows in a positive direction
(towards higher addresses), whereas segment 1 grows in the negative direction.

Visually, the address space looks like this:

 --------------- virtual address 0
 |    seg0     |
 |             |
 |             |
 |-------------|
 |             |
 |             |
 |             |
 |             |
 |(unallocated)|
 |             |
 |             |
 |             |
 |-------------|
 |             |
 |    seg1     |
 |-------------| virtual address max (size of address space)

With segmentation, as you might recall, there is a base/limit pair of
registers per segment. Thus, in this problem, there are two base/limit
pairs. The segment-0 base tells which physical address the *top* of segment 0
has been placed in physical memory and the limit tells how big the segment is;
the segment-1 base tells where the *bottom* of segment 1 has been placed in
physical memory and the corresponding limit also tells us how big the segment
is (or how far it grows in the negative direction).



For example, to run with the default flags, type:

prompt> ./segmentation.py 

(or 
prompt> python ./segmentation.py 
if that doesn't work)

You should see this:
  ARG seed 0
  ARG address space size 1k
  ARG phys mem size 16k
  
  Segment register information:

    Segment 0 base  (grows positive) : 0x00001aea (decimal 6890)
    Segment 0 limit                  : 472

    Segment 1 base  (grows negative) : 0x00001254 (decimal 4692)
    Segment 1 limit                  : 450

  
Of course, there are some parameters you can use to give yourself different
problems. One particularly important parameter is the -s or -seed parameter,
which lets you generate different problems by passing in a different random
seed. Of course, make sure to use the same random seed when you are generating
a problem and then solving it.

There are also some parameters you can use to play with different-sized
address spaces and physical memories. For example, to experiment with
segmentation in a tiny system, you might type:

  prompt> ./segmentation.py -s 100 -a 16 -p 32
  ARG seed 0
  ARG address space size 16
  ARG phys mem size 32
 
  Segment register information:

    Segment 0 base  (grows positive) : 0x00000018 (decimal 24)
    Segment 0 limit                  : 4

    Segment 1 base  (grows negative) : 0x00000012 (decimal 18)
    Segment 1 limit                  : 5

  Virtual Address Trace
    VA  0: 0x0000000c (decimal:   12) --> PA or segmentation violation?
    VA  1: 0x00000008 (decimal:    8) --> PA or segmentation violation?
    VA  2: 0x00000001 (decimal:    1) --> PA or segmentation violation?
    VA  3: 0x00000007 (decimal:    7) --> PA or segmentation violation?
    VA  4: 0x00000000 (decimal:    0) --> PA or segmentation violation?

which tells the program to generate virtual addresses for a 16-byte address
space placed somewhere in a 32-byte physical memory. 

This example should also show you exactly what each base pair means. For
example, segment 0's base is set to a physical address of 24 (decimal) and is
of size 4 bytes. Thus, *virtual* addresses 0, 1, 2, and 3 are in segment 0 and
valid, and map to physical addresses 24, 25, 26, and 27, respectively. 

Slightly more tricky is the negative-direction-growing segment 1. In the tiny
example above, segment 1's base register is set to physical address 18, with a
size of 5 bytes. That means that the *last* five bytes of the virtual address
space, in this case 11, 12, 13, 14, and 15, are valid virtual addresses, and
that they map to physical addresses 13, 14, 15, 16, and 17, respectively.

If that doesn't make sense, read it again -- you will have to make sense of
how this works in order to do any of these problems.

Note you can specify bigger values by tacking a "k", "m", or even "g" onto the
values you pass in with the -a or -p flags, as in "kilobytes", "megabytes",
and "gigabytes". Thus, if you wanted to do some translations with a 1-MB
address space set in a 32-MB physical memory, you might type:

prompt> ./segmentation.py -a 1m -p 32m

If you want to get even more specific, you can set the base register and limit
register values yourself, with the --b0, --l0, --b1, and --l1 registers. Try
them and see.

Finally, you can always run 

prompt> ./segmentation.py -h 

to get a complete list of flags and options.





